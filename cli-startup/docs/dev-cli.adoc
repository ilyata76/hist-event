# Руководство разработчика

## Абстракции

на текущем этапе 24.09.23

* Сущность - описываемая историческая сущность. Например, событие. У этой сущности есть поля её описания, например, дата события или интервал события-процесса. Описываются отдельными pydantic-классами в `.schemas`

* Хранилище сущностей. Для каждой сущности должно быть определно своё хранилище, определяющую логику работы над сущностями, будь то генерация SQL запроса, будь то просто хранение конкретного класса сущности. Своё хранилище для чёткого разделения

* Класс управления хранилищами. Инкапсулирует логику работы со всеми хранилищами до той степени, что сохранение в конкретное из хранилищ требует лишь `entity` и `keyword`.

* Основные процессы - функции, отвечающие за работу приложения, парсинг, генерация, валидация. Работают со `Storages`-классом, который инкапсулирует в себя всю оставшуюся логику.

## Добавить новую сущность на уровне кода
Сущность - главный и почти что единственный элемент cli-приложения, добавление новой сущности затрагивает почти все процессы его работы. Здесь описано, в какие из них нужно прямое вмешательство.

Чтобы добавить новую сущность на уровне кода, необходимо:

* В файле `config.py` в классе `ParseKeyword` определить константы и ключевые слова, которые будут использоваться при проходе текстов (например, description-поля) для таких форм: `{>КЛЮЧЕВОЕ СЛОВО<:ID}[замещающий текст]`

[source, python]
----
class ParseKeywords :
    date = "date"
    person = "person"
    ...
    # код здесь
----

* В файле `config.py` в классе `ConfigKeywords` определить специфические константы-названия_полей для определяемой сущности, а также, если на сущность можно будет ссылаться, константы-названия_полей для хранения ссылок

[source, python]
----
class ConfigKeywords :
    name : str = "name"
    id : str = "id"
    ...
    # код для констант здесь
    ...
    dates : str = "dates" # set[int] для внутренних ссылок
    ex_dates : str = "ex_dates" # для внешних
    ...
    # код для ссылок (внутренних и внешних) на сущность здесь
----

* Создать классы сущности и хранилища для сущностей в папке `schemas`, отнаследовавшись от `BaseEntity` и `BaseStorage`, поля должны соответствовать `str`-описаниям из конфига, описать методы по подобию существующим сущностям. А также функции, генерирующие `SQL`-код. НАПРИМЕР:

[source, python]
----
def generateTableSQL(self) -> str:
    ...
    str_include  = f"\t{ConfigKeywords.author} TEXT NOT NULL,\n" # у последней строки в наборе str_include не должно быть запятой и перевода строки
    ...
    return super().generateTableSQL(str_include)
...

def fillTableSQL(self) -> str:
    ...
        if type(x) is Biblio :
            str_include  = f"\t  {NOV(x.author)}, {NOV(x.link)}, {NOV(x.date)},\n"
            str_include += f"\t  {NOV(x.state)}, {NOV(x.period)}"
            str_result = super().fillTableSQL(x, str_include)
            ary.append(str_result)
    ...
    return result
----

* Добавить в `Entity.py` у `BaseEntity` новые поля, `{keywords}`, `ex_{keywords}` 
** Добавить у `BaseEntity` новые строки в функциях генерации SQL-запроса:

 [source, python]
 ----
 def generateTableSQL(self, str_include : str = "") -> str :
    ...
    str_result += # новые строки здесь
    str_result += f");"
 ...

 def fillTableSQL(self, element : BaseEntity, str_include : str = "") -> str :
    ...
    str_result += f"\t  {NOV(element.biblios)}, {NOV(element.ex_biblios)},\n"
 ...
 # новые строки здесь
 ----

* В `Storages.py` добавить новое хранилище сущностей как дополнительное  к существующим. А также добавить выбор хранилища в необходимых местах (`match`/`case`)

** В конструктор, в `__init__`

** Далее, в функциях `__getKeywordStorageDict`, `__getParseKeywordKeywordDict`, `__getReversedKeywordKeywordDict` прописать связи между ключом и значением по аналогии с остальными

** Дополнить методы `Storages`-класса с учётом новодобавленной сущности (в частности, в массив для функций, генерирующих SQL) в необходимом для сущности порядке следования.

* Далее, в файле процесса `parse.py` в функции `getEntity` нужно описать процесс создания сущности
** Через `dict.get(keyword, None)` спарсить специфические значения
** В `match`/`case` по `keyword` добавить логику создания сущности:
 
 [source, python]
 ----
    ...
    case config.ConfigKeywords.places :
        entity_to_append = Place( name=name, 
                                  id=id, 
                                  description=description, 
                                  geo=geo )
        ...
        # логика здесь
 ----

* При необходимости, если у сущности есть поля, которые стоит обрабатывать на ссылки, в функции `parseFile` стоит добавить:
 
[source, python]
----
   ...
   if description :
       if storages.saveAndRegisterEntitites(description, patternTextInclusion(), keyword, id) == 2 :
           res_code = 2
   ...
   # код обработки здесь
----

** Далее, в `parse` добавить в словарь ключ-значение для хранение кода:

[source, python]
----
codes = {
    ConfigKeywords.biblio_fragments : 2,
    # добавить здесь
}
----

* В классе Paths, в `__init__`, а также в функции `__pathByKeywordDict` прописать логику работы с путём до файла

* Если путь до `yaml`-файла может быть проложен самостоятельно, в `cli.py` необходимо его прописать в качестве switch

* В файле `validate.py` прописать правила новодобавленный полей

* Проверить работоспособность новой конфигурации

Такая сложность добавления зависит главным образом от неавтоматизированных интерфейсов связи SQL базы данных и CLI, генерирующую SQL файл, а также невозможностью предусмотреть и нежеланием ограничивать действия пользователя


## Добавить поля к уже существующей сущности на уровне кода

Чтобы добавить новые поля, необходимо:

* В файле `config.py` прописать в `ConfigKeyword` новые поля

[source, python]
----
class ConfigKeywords :
    name : str = "name"
    id : str = "id"
    ...
    # код здесь
----

* В `schemas` в модели сущности прописать новые поля

[source, python]
----
class Source(BaseEntity) :
    ...
    type : str | None = None
    subtype : str | None = None
    # новые поля
----

* Там же, но уже в хранилище сущности в функциях генерации SQL-запросов, прописать новые поля

[source, python]
----
def generateTableSQL(self) -> str:
    ...
    str_include += f"\t{ConfigKeywords.type} TEXT,\n"
    str_include += f"\t{ConfigKeywords.subtype} TEXT"
    # новые поля
    return super().generateTableSQL(str_include)
...

def fillTableSQL(self) -> str:
    ...
            str_include += f"\t  {NOV(x.type)}, {NOV(x.subtype)}"
            # новые поля
            str_result = super().fillTableSQL(x, str_include)
    ...
    return result
----

* В `parse.py/getEntity` прописать в строке `.get` для новых полей, а также добавить в `match`/`case` при создании сущности новые поля

[source, python]
----
def getEntity(dict_entity : dict, keyword : str, id : int,
              storages : Storages) -> [int, BaseEntity] :
    ...
    type = dict_entity.get(ConfigKeywords.type, None)
    subtype = dict_entity.get(ConfigKeywords.subtype, None)
    # новые .get здесь
    ...
    match keyword :
        case X :
            # добавление здесь
    ...
----

* В файле `validate.py` прописать правила новодобавленный полей

* Проверить работоспособность новой конфигурации