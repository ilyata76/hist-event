# Главная идея

Представление исторического или любого другого события в виде графа или древовидной структуры. Таким образом, выделяя разного рода сущности, ивенты и даты, и пр., можно собирать, как из кубиков, какое-либо большое событие или процесс, например, столыпинские реформы. Все события будут описываться в YAML-файлах

# Разделяя на два

Сейчас (21.11.23) проект представляет собой два интерфейса с прилегающими к ним микросервисами.

*TODO картинка архитектуры*

## Graph

Реализация главной идеи. То, что будут видеть пользователи.
Этот интерфейс будет отрисовывать граф на клиенте. Также он будет генерировать страницы записей (например, если тыкнуть на какое-нибудь подсобытие, то его текст соберётся из вложенных, тем самым будет сгенерирован). Концепт странички ещё не разработан.

Связанные микросервисы:
- [[graph-api]] + [[graph-interface]] для функционирования сайта
- [[sql-database]] для хранения сущностей, текстов, и связей между ними
- [[sql-database-api]] для доступа к этим сущностям
- [[file-api]] для загрузки на страницы картинок, приложенных файлов и пр.

## Control

Реализация идеи реактивного управления содержимым графа. Так, админ (историк) может загружать новые конфигурационные YAML-файлы для сущностей, восстанавливать предыдущие, менять различные тексты.
Связь с [[graph-interface]] будет посредством изменения общеприложенных микросервисов (для сущностей - [[sql-database]])

Связанные микросервисы:
- [[control-api]] + [[control-interface]] для функционирования сайта
- [[nosql-database]] для хранения любой необходимой информации
- [[nosql-database-api]] для доступа к ней
- [[file-api]] для доступа к файлам, для загрузки файлов
- [[ftp-io]] для хранения файлов локально, без [[S3]]
- [[sql-generator]] для генерации SQL-запроса, которым будет инициализирована/изменена база данных [[sql-database]]

Также контролирующий сервис должен позволять управлять всеми файлами, например, загрузкой картинок, которые бы через ссылки интерпретировались в [[graph-interface]]

# Структура

Приложение состоит из двух интерфейсом, обычный пользователь из которых видит только один - [[graph-interface]]. Два интерфейса связаны между собой через общие - баз данных. Таким образом на граф будет действовать управление, тем самым создавая реактивность решения. 
Приложение будет оперировать такими понятиями, как:
- событие
- надсобытие - событие, состоящие из "событий", стоящее над ними
- подсобытие - событие, из которых строится "надсобытие" как "событие"
Так, структура и связи между этими сущностными событиями будут определять конечную структуру дерева или графа. Помимо событий, они дополняются также другими сущностными абстракциями, ссылаются на них, связываются через них (например, для построения таймлайна)

## Элементарные сущности

Каждое событие состоит и/или ссылается (прямо в тексте) на другие элементарные сущности:
- сущность даты, `dates`, описывает "когда происходило или произошло то или иное событие или процесс"
- сущность личности, `person`, связана с событиями лишь опосредованно
- сущность места, `place`, связана с событиями лишь опосредованно
- сущность библиографического источника `biblio`, а также сущность фрагмента из библиографического источника `biblio_fragment`
- сущность исторического источника `source`, фрагмента - `source_fragment`
- сущность для всего остального, чему можно дать полезное описание, `other`
- сущность связи между событиями `bond` - ограниченная сущность, на неё нельзя ссылаться.

### Файлы

Определение сущностей идёт по ключевым словам в начале перечисления. Так, можно описать все сущности в одном файле

```yaml
keyword*:
	- ...
	- ...
	- ...
```

### Сущности

Заголовки представлены в виде названия сущности и ключевого слова, после которого должно идти перечисление массива сущностей. **Обязательные поля указаны со звёздочкой**

#### event (events)

Поля `min` и `max` реализуют идею одновременной самодостаточности описания события и возможности вложенной вставки одного события в другие.

```yaml
	- id*: int
	  name*:
	  date*: int
	  min*:
	  max*:
	  level:
	  description:
```
#### date (dates)

Дата должна содержать либо `point`, что указывает на одновременность события, либо `process`, что указывает на его продолжительность.
Если даты используются в качестве дат жизни, то `point` можно использовать как дату рождения.

```yaml
	- id*: int
	  name*:
	  point:   <---------- XOR
		  date*: ISO
		  time: ISO
	  process: <---------- XOR
		  start*:
			  date*: ISO
			  time: ISO
		  end*:
			  date*: ISO
			  time: ISO
	  description:
```

#### place (places)

Геометка может использоваться для интеграции с сервисами онлайн-карт

```yaml
	- id*: int
	  name*:
	  geo:
		  latitude*: float
		  logitude*: float
	  description:
```

#### peron (persons)

Указанная ссылка на дату, подразумевается, - это даты жизни личности. Может ссылаться на `date` с указанным `point`.

```yaml
	- id*: int
	  name*:
	  date*: int
	  description:
```

#### biblio (biblios)

Может ссылаться на `date` с указанным `process`, указывая тем самым возможный промежуток публикации.

```yaml
	- id*: int
	  name*:
	  date: int
	  author: int
	  state:
	  period:
	  link:
		  web: http    <--- OR/AND
		  native:      <--- OR/AND
	  description:
```

#### biblio_fragment (biblio_fragments)

```yaml
	- id*: int
	  name*:
	  biblio*: int
	  description:
```

#### source (sources)

Аналогично `biblio`

```yaml
	- id*: int
	  name*: int
	  author: int
	  date: int
	  type:
	  subtype:
	  link:
		  web: http   <--- OR/AND
		  native:     <--- OR/AND
	  description:
```

#### source_fragment (source_fragments)

```yaml
	- id*: int
	  name*:
	  source*: int
	  description:
```

#### other (others)

Поле `meta` может быть использовано для абсолютно любых целей. `description` определит возможное описание, если таковое будет необходимо

```yaml
	- id*: int
	  name*:
	  meta:
	  description:
```

### Связи

Может быть реализовано несколько связей - событийное (parent-child), а также предпосыльное, если события не укладываются в общую архитектуру дерева или графа.

#### bond (bonds)

Сущность связей реализует главную идею приложения

```yaml
	- event*: int
	  parents: array[int]
	  childs: array[int]
	  prerequisites: array[int]
```

### Пример

Файл `biblios.yaml` может быть рассмотрен системой по двум `keyword` : `biblios` и `biblio_fragments`

```yaml
biblios :
  - id: 1
    name: "книшка"
    description: "описании книшки"
    date: 1
    period: "советский"
    state: "USSR"
    author: 1
    link:
      web: "https://aboba.ru"
  - id: 2
    name: "aboba name"
    author: 2
    link:
      web: "https"

biblio_fragments :
  - id: 1
    name: "ссылка на главу с абобой"
    biblio: 2
    description: "абоба в беде"
```


## Вставки

Каждый текст у сущностей, `description` у всех, `min`, `max` - у событий, может обрабатывать вставки, сохраняя их для работы на графе.
```
{KEYWORD:ID}[TEXT]
{source:1}[Согласно закону...], следовало ...
```
Такие вставки будут обрабатываться в части [[graph-interface]], создавая гиперссылку на новую сущность, поля которой определены. Генерация странички для каждой сущности по запросу позволит содержать любые гиперссылки.

### Картинки 

На текущий момент не реализовано (21.11.2023)
*TODO*

## Связь между событиями

Все события реализуют между собой два вида связи :
- прямо-событийная: события связаны между собой над-под-событийно
- предпосыльная: если событие не укладывается в первую связь, оно является предпосыльным (например, ПМВ при рассмотрении ВМВ)

![[eventbond.png]]

Все события должны соответствовать двум критериям, реализуя главную идею решения: 
1. каждое событие должно быть самодостаточным настолько, чтобы кратко и лаконично описывать себя без вставок других, хоть и связанных, событий, что приводит к повторению текстов. Такие самодостаточные описания могут использоваться как вставки в другие. 
2. каждое событие должно быть способно, если оно не на самом высоком уровне, быть встроенным в другое событие; также, соответственно, каждое событие должно отражать полноту своего описания посредством каскадной вставки текстов "подсобытий"

### Уровни

Для определения алгоритма вставки событий они разделяются на уровни:
1. уровень ФАКТА. Описывает какой-либо состоявшийся факт или небольшой процесс. Не имеет вставок. То есть `min` и `max` отображения различаются только объёмом текста. Обозначим его как `{FACT}`
2. уровень ОБОБЩЕНИЯ. Все факты, для которых текущий элемент обобщения является родительским, вкладываются в его текст. То есть `ТЕКСТ {FACT} ТЕКСТ {FACT}`
3. уровень ПРОЦЕССОВ. Все обобщения, для которых текущей элемент процесса является родительским, вкладывается в текст процесса, но таким образом, что каждый элемент уровня ФАКТА будет сокращён до `min`, т.е. если `ТЕКСТ` обобщения обозначить как `COM`, а `ТЕКСТ` - это текст процесса, то `ТЕКСТ {COM} {FACT:MIN} {COM} {FACT:MIN} ТЕКСТ ТЕКСТ`
5. уровень СОСТОЯНИЯ. Все процессы вкладываются как полноценные абзацы текста, таким образом будет `ТЕКСТ... \n\t{PROC}`
6. уровень ДОМЕНА. Все состояния вкладываются сюда как подзаголовки.
7. уровень ЯДРА. Все домены вставляются сюда как отдельно стоящие заголовки.

### Обход

Пока что алгоритм обхода не реализован (21.11.2023)
*TODO*

# Хранимые файлы

TODO

# Последовательность действий
от составления до получения графа

1. Историк (админ) собирает (каким угодно образом) YAML-файлы с описанными событиями
2. Заходит на [[control-interface]], выбирает изменить/загрузить контент
3. После выбирает добавление новых файлов, которые сохраняются в [[file-api]]
4. Нажимает "провалидировать", запуская процесс валидации у [[sql-generator]]. В случае успеха, сервис сохранит всю метаинформацию через [[nosql-database-api]].
5. После нажимает кнопку "загрузить контент", который запускает у [[sql-generator]] процессы дополнительной проверки связей. В случае успеха, обновляет информацию через [[sql-database-api]] на [[graph-interface]]

*TODO мануал по использованию* 